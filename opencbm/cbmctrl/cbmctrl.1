.\" $Id: cbmctrl.1,v 1.7.2.1 2007-11-11 17:48:42 strik Exp $
.\"
.\" This manual page was written by Michael Klein
.\"   <michael(dot)klein(at)puffin(dot)lb(dot)shuttle(dot)de>,
.\" additions and rework by Wolfgang Moser <cbm(a)d81(o)de>
.\"
.\" Process this file with
.\"    groff -t -e -mandoc -Tps cbmctrl.1 > cbmctrl.1.ps
.\" Test it with
.\"    nroff -man cbmctrl.1 | less -r
.\"
.TH CBMCTRL "1" "April 2006" "cbmctrl 0.4.1" "User Commands"
.SH NAME
 cbmctrl \- manual page for cbmctrl 0.4.1
 - control serial CBM devices
.P
.B This document is poorly maintained and probably outdated. 
If in doubt, use the Texinfo manual. If the
.B info
program is properly installed at your site, the command
.IP
.B info opencbm
.PP
should give you access to the complete manual.
.SH SYNOPSIS
.B cbmctrl " [global_options] [action] [action_args]"
.SH DESCRIPTION
.B cbmctrl
can control all kinds of serial CBM devices like floppy drives and printers.
So far, it has been successfully tested with the disk drives
.SM 1541(-II),
.SM 1571
and a
.SM MPS-1200
printer.
.SH Structure
.B Overall structure of cbmctrl actionss
.RS 4
The overall format of all
.B cbmctrl
actions is:
.RS 2
.TP
.BI cbmctrl " [global_options]" " [action]" " [action_args]"
.RE
.TP 2
.BI cbmctrl
The name of the
.B cbmctrl
program
.TP 2
.I global_options
Some options that are related to
.B cbmctrl
in general or affect the overall behaviour of all actions
.TP 2
.B action
One of a bunch of different subcommands that direct
.B cbmctrl
what to do
.TP 2
.I action_args
Arguments that are required for the subcommand
.B action
to work
.RE
.SH OPTIONS
.B Global options
.RS 4
.B cbmctrl
understands the following global options
.PP
.PD 0
.RS 2
.TP 7
.B \-h
.I [<action>]
.TP 7
.B \-\-help
.I [<action>]
.RS
Outputs the help screen with a short listing of all available
actions. If the optional
.I <action>
name is given also, you retrieve more information on a specific
action together with its arguments and parameters
.RE
.PD
.TP
.B \-V, \-\-version
Output version information as well as the build date and time.
.RE
.RE
.PP
.B Actions overview
.RS 4
.B cbmctrl
understands the following subcommand actions
.RS 2
.TP 10
.B reset
\- Reset all drives on the IEC bus
.br
.ns
.TP 10
.B detect
\- Detect all drives on the IEC bus
.br
.ns
.TP 10
.B lock
\- Lock the parallel port for cbm4win/cbm4linux use
.br
.ns
.TP 10
.B unlock
\- Unlock the parallel port from exclusive usage
.br
.ns
.TP 10
.B listen
\- Perform a listen on the IEC bus
.br
.ns
.TP 10
.B talk
\- Perform a talk on the IEC bus
.br
.ns
.TP 10
.B unlisten
\- Perform an unlisten on the IEC bus
.br
.ns
.TP 10
.B untalk
\- Perform an untalk on the IEC bus
.br
.ns
.TP 10
.B open
\- Perform an open on the IEC bus
.br
.ns
.TP 10
.B close
\- Perform a close on the IEC bus
.br
.ns
.TP 10
.B popen
\- Same as open, but with ASCII to PETSCII conversion
.br
.ns
.TP 10
.B read
\- Get a stream of raw data from an IEC bus device
.br
.ns
.TP 10
.B write
\- Put a stream of raw data to an IEC bus device
.br
.ns
.TP 10
.B status
\- Give the status of a specified drive
.br
.ns
.TP 10
.B command
\- Issue a command to a specified drive
.br
.ns
.TP 10
.B pcommand
\- Same as command, with ASCII to PETSCII conversion
.br
.ns
.TP 10
.B dir
\- Output the directory of a disk in a specified drive
.br
.ns
.TP 10
.B download
\- Download memory contents from a floppy drive
.br
.ns
.TP 10
.B upload
\- Upload memory contents to a floppy drive
.br
.ns
.TP 10
.B change
\- Wait for a disk to be changed in a specified drive
.RE
.RE
.PP
.B Common action arguments
.RS 4
Many of the
.B cbmctrl
subcommands understand the following common arguments:
.RS 2
.TP 2
.I <device>
Advice
.B cbmctrl
to direct its communication to the IEC bus device with the number
.I <device>.
IEC bus device numbers can be denoted in the range from 0 to 30,
although no Commodore device is known to use device numbers 0 to 3.
Most commonly used are the numbers 4 (printer) and 8 to 11 (disk
drives). Device number 31 is used to denote the UNTALK respectively
the UNLISTEN command code on the IEC bus instead of the TALK
respectively LISTEN command code, therefore device address 31
cannot be used in general.
.TP
.I <secadr>
With several
.B cbmctrl actions
the secondary address parameter
.I <secadr>
denotes a dedicated logical communication channel for the specified
.IR <device> .
IEC bus channel numbers can be denoted in the range from 0 to 15.
Take note that for floppy disk drive devices some secondary
addresses are interpreted in a special way. Secondary address 0
is used, when a program is loaded, address 1, when a program is
saved. Address number 15 represents the command channel of the
disk drive, so effectively, for bulk data transfers to and from
disk drives, only the logical channel numbers 2 to 14 can be used.
.RE
.RE
.SH Actions
.B cbmctrl
understands the following
.B actions:
.TP
.BI reset
This action performs a hardware reset of all devices attached to the IEC bus.
Control is returned after it is made sure that all devices are ready.
.TP
.BI detect 
This action tries to detect all devices attached to the IEC bus.
For this, this subcommand accesses all possible devices and tries to
read some bytes from its memory. If a devices is detected, its name
is output. Additionally, this routine determines if the device is
connected via a parallel cable (XP1541 companion cable, may be true
for disk drives only).
.TP
.BI lock
This command locks the parallel port for exclusive use by cbm4win/cbm4linux, so
that sequences of e.g. talk/read/untalk commands are not broken by concurrent
processes wanting to access the parallel port.
.RS
.PP
Best practice is it to enclose each such sequence that contains either talk,
untalk, listen, unlisten, open, close, read or write by a lock/unlock pair of
commands. Scripting systems or other software systems using cbmctrl instead of
the OpenCBM API should issue a 
.B cbmctrl lock
command on startup and a
.B cbmctrl unlock
upon (each) exit.
.RE
.TP
.BI unlock
Ends exclusive parallel port access by opencbm so that other
processes are allowed to access the parallel port.
.TP
.BI listen " <device> <secadr>"
Tell device
.I <device>
to listen on secondary address
.IR <secadr> .
Until the next
.B unlisten
command, everything written with the action command
.B write
(see below) will be received by this device. Take note that a
.B listen
command has to be undone later with an
.B unlisten
(see below) command.
.RS
.PP
This command corresponds to the following 6502 assembler code on a C64:
.RS
.PD 0
.P
lda #dev
.P
jsr $ffb1
.P
lda #sa
.P
ora #$60
.P
jsr $ff93
.PD
.RE
.RE
.TP
.BI talk " <device> <secadr>"
Tell device
.I <device>
to talk on secondary address
.IR <secadr> .
Until the next
.B untalk
command, data from this device can be received by reading with the
action command
.B read
(see below). Take note that a
.B talk
command has to be undone later with an
.B untalk
(see below) command.
.RS
.PP
This command corresponds to the following 6502 assembler code on a C64:
.RS
.PD 0
.P
lda #dev
.P
jsr $ffb4
.P
lda #sa
.P
ora #$60
.P
jsr $ff96
.PD
.RE
.RE
.TP
.BI unlisten
Ends communication with listening devices by undoing one or more
previous
.B listen
or
.B talk
commands. This IEC command affects all devices on the bus; it
corresponds to the C64 kernel routine $ffae.
.TP
.BI untalk
Ends communication with talking devices by undoing one or more
previous
.B listen
or
.B talk
commands. This IEC command affects all devices on the bus; it
corresponds to the C64 kernel routine $ffab.
.TP
.BI open " <device> <secadr> <filename>"
Open file
.I <filename>
on device
.IR <device> .
After opening, data can be read/written by sending a
.B talk
resp.
.B listen
command with secondary address
.IR <secadr> .
Take note that an
.B open
command has to be undone later with a
.B close
command.
.PP
.RS
.PD 0
Notes:
.RS 2
.TP 2
*
If
.I <secadr> 
is greater than 1, file type and access mode must also be specified
by appending 
.I ",<type>,<mode>"
to
.IR <filename> .
Valid types are
.BR D ,
.BR P ,
.BR S ,
.BR U
and 
.B R
(del, prg, seq, usr, rel), valid modes are 
.B R
for reading and
.B W
for writing.
.TP 2
*
You cannot do an open without a filename. Although a CBM machine
(i.e., a C64) allows this, it is an internal operation to that
computer only.
.TP 2
*
.BI cbmctrl " open"
does not change any character encoding, that is, it does not convert
between ASCII (used by the PC) and PETSCII (used by the CBM device).
If this is needed, use
.BI cbmctrl " popen"
instead.
.RE
.PD
.RE
.TP
.BI popen " <device> <secadr> <filename>"
The
.B popen
action is the very same as the
.B open
action and all parameters act the same. The difference is that the
.I <filename>
string is converted from ASCII to PETSCII before beeing sent to the
device.
.PP
.RS
.PD 0
Notes:
.RS 2
The same notes as with the
.B open
action apply to the
.B popen
action.
.RE
.PD
.RE
.TP
.BI close " <device> <secadr>"
Close the file associated with secondary address
.I <secadr>
on device
.IR <device> .
This undoes a previous
.BR open " or" " popen"
command.
.TP
.BI read " [<file>]"
Reads raw data from a device, after it has been set into
.B talk
mode. The data stream may be stored into a file named by
the optional parameter
.IR <file> .
If
.I <file>
is omitted or if it is named -, the data stream is put to
the standard output channel on the host computer.
.TP
.BI write " [<file>]"
Writes raw data to a device, after it has been set into
.B listen
mode. The data stream may be taken from a file named by
the optional parameter
.IR <file> .
If
.I <file>
is omitted or if it is named -, the data stream is get from
the standard input channel on the host computer.
.TP
.BI status " <device>"
Copies input from device
.IR <device> ,
secondary address 15 (command/status channel), to standard out. Note that
all upper case characters are changed to lower case. Carriage return (0x0d)
is also changed to the current operating systems line ending convention
(0x0a on Unix oriented systems, 0x0d 0x0a on Windows oriented systems).
.PP
.RS
This action is similar to (in this case, no character conversions would be
made):
.PP
.PD 0
.RS
cbmctrl lock
.P
cbmctrl talk
.I <device>
15
.P
cbmctrl read
.P
cbmctrl untalk
.P
cbmctrl unlock
.PD
.RE
.RE
.TP
.BI command " <device> <cmdstr>"
Sends
.I <cmdstr>
to device
.IR <device> ,
secondary address 15 (command/status channel). Note that most (all?)
devices accept upper case commands only, lower case will not work
(i.e., N: to format a drive, V: to validate, etc.)!
.PP
.RS
This command is identical to:
.PP
.PD 0
.RS
cbmctrl lock
.P
cbmctrl listen
.I <device>
15
.P
echo -n
.I <cmdstr>
| cbmctrl write
.P
cbmctrl unlisten
.P
cbmctrl unlock
.PD
.P
(NOTE: "echo -n" does natively work under Linux only)
.RE
.RE
.TP
.BI pcommand " <device> <cmdstr>"
The
.B pcommand
action is the very same as the
.B command
action and the
.I <device>
parameter acts the same. The difference is that the
.I <cmdstr>
string is converted from ASCII to PETSCII before beeing used.
.PP
.RS
.PD 0
Notes:
.RS 2
.TP 2
*
Despite the
.B command
action command, all commands (stated within
.IR <cmdstr> )
have to be given in lower case letters. The letter case conversion is one of
the things the ASCII to PETSCII conversion does.
.TP 2
*
Due to the conversion from ASCII to PETSCII, sending
.IR """m-r""" " and" " ""m-w"""
device commands will not work in most cases, because the data to be sent
will be converted too and thus corrupts the stream.
.RE
.PD
.RE
.TP
.BI dir " <device>"
Display the directory from the disk in the specified disk drive
IEC device
.IR <device> .
.TP
.BI download " <device> <address> <count> [<file>]"
Read
.I <count>
bytes from a disk drive's memory, starting at
.I <address>
via one or more
.BI M-R
commands. Memory contents are written to standard output as long as
.I <file>
is ommited or equivalent to -. Note that
.I <count>
and
.I <address>
accept decimal as well as sedecimal (hexadecadic) numbers when
prefixed with 0x or 0X (but not with the usual $ sign).
.TP
.BI upload " <device> <address> [<file>]"
Send
.I <file>
to drive memory, starting at
.I <address>
via one or more
.BI M-W
commands. If
.I <address>
is -1, the first two bytes from
.I <file>
are considered as start address. Reads standard input if
.I <file>
is ommited or equivalent to -.
.I <count>
and
.I <address>
accept decimal as well as hex numbers (with 0x or 0X prefix).
.TP
.BI cbmctrl " change <device>"
This action advises a disk drive IEC device with number
.I <device>
to wait for a disk to be exchanged. It makes the following assumptions
for this:
.PP
.PD 0
.RS 10
.TP 2
*
there is already a disk in the drive,
.TP 2
*
that disk will be completely removed and replaced by another disk,
.TP 2
*
we do not want to return from this command until the disk is
completely inserted and ready to be read/written.
.PD
.RE
.PP
.RS
Because of this, just opening the drive and closing it again (without
actually removing the disk) will not work in most cases.
.RE
.SH EXIT CODES
.B cbmctrl
sets the exit code to 0, if the operation completed successfully.
It exits with 2 if the command parser detected a problem with the
number of arguments, their size or the combination of commands and
options.
.PP
Take note that each command action does return its own exit codes
(mostly 0 for success and 1 as a failure indicator). The exact
exit code, especially when looking to failure conditions, is
platform and implementation (driver) specific, because operation
system specific error codes are used often.
.SH BUGS
Due to the nature of
.B cbmctrl
beeing a command (sub-) processor, the global options are currently
also beeing interpreted as commands and therefore cannot be combined.
For example,
.PP
.RS
.BI cbmtrl " -V --help" " change"
.RE
.PP
does not work and leads to an error message.
.PP
The
.B lock/unlock
actions are currently without any functionality within the cbm4linux driver.
They can be issued without any failure, but actually the parallel port becomes
not explicitly locked/unlocked to the driver. That way scripts containing
.B lock/unlock
commands can be ported from Windows to Linux without changes.
.SH EXAMPLES
.TP
Send file contents to printer #4:
.RS
.PD 0
cbmctrl lock
.P
cbmctrl listen 4 0
.P
cbmctrl write
.I filename
.P
cbmctrl unlisten
.P
cbmctrl unlock
.PD
.RE
.TP
Copy file to disk drive #8:
.RS
.PD 0
cbmctrl lock
.P
cbmctrl open 8 2
.IR CBMNAME ,P,W
.P
cbmctrl listen 8 2
.P
cbmctrl write
.I filename
.P
cbmctrl unlisten
.P
cbmctrl close 8 2
.P
cbmctrl unlock
.PD
.RE
.TP
Copy file from disk drive #8:
.RS
.PD 0
cbmctrl lock
.P
cbmctrl open 8 2
.IR CBMNAME ,P,R
.P
cbmctrl talk 8 2
.P
cbmctrl read
.I filename
.P
cbmctrl untalk
.P
cbmctrl close 8 2
.P
cbmctrl unlock
.PD
.RE
.TP
Download the #9 disk drive DOS ROM to file:
.RS
cbmctrl download 9 0xc000 0x4000
.I 1541ROM.BIN
.RE
.TP
Transfer file to disk drive #10, buffer at address $500:
.RS
cbmctrl upload 10 0x500
.I BUFFER2.BIN
.RE
.SH AUTHOR
Michael Klein <michael(dot)klein(at)puffin(dot)lb(dot)shuttle(dot)de>,
additions and reworks by Spiro Trikaliotis, additions by Wolfgang Moser
<cbm(a)d81(o)de>.
.SH DATE
Apr 27 2006
