
; This program is heavily based on Joe Forster/STAs <sta@c64.org>
; StarCommander Turbo routines.
;
; "$Id: cbmformat.a65,v 1.2 2005-04-17 15:32:17 strik Exp $"


JOB_BUMP	= $C0 ; bump the head
JOB_EXEC2	= $E0 ; execute after drive runs

CMDNUM_NEW	= $0B ; command number for "NEW" command

TRACK2	= $0A ; track for buffer 2 ($0500-$05FF)
SECTOR2	= $0B ; sector for buffer 2 ($0500-$05FF)
HDRID1	= $16 ; 1st character of disc ID
HDRID2	= $17 ; 2nd character of disc ID
DRVTRK	= $22 ; Track currently under R/W head on drive #0
BUFPTR	= $30 ; Pointer to the currently active buffer
HDRPNT	= $32 ; Pointer to active values in header
HBID	= $39 ; Header block ID ($08)
CHKSUM	= $3A ; storage for data or header checksum
SECTR	= $43 ; sector counter
GAPLEN	= $90 ; temporary storage
FILDRV	= $E2 ; default flag, drive # (all 0 on 1541)
JOBNUM	= $F9 ; current job number
CMDNUM	= $22A ; command code number
FILTBL	= $27B ; ???

STACK	= $0100
CMDBUF	= $0200
BUFFER0	= $0300
BUFFER1	= $0400
BUFFER2	= $0500
BUFFER4	= $0700

BC_PB	= $1800

DC_SETTINGS	= $1C00
DC_DATA	= $1C01
DC_DATADDR	= $1C03
DC_PCR	= $1C0C

TAGCMD	= $C1EE ;
ONEDRV	= $C312
SETDRIVENUM	= $C388
INITDR	= $D042
DOJOB	= $D58C
WRITEBAM	= $EE40
MAXSEC	= $F24B
BINGCR	= $F78F
ERRR	= $F969
STPIN	= $FA63
MOVUP	= $FDE5
MOVOVR	= $FDF5
KILL	= $FE00
FBTOG	= $FE30
ZONEBOUNDARIES	= $FED7
SLOWS	= $FEF3


StartTrack = 1
Security = 2
MinGAP = 5

DebugFormat = 1
; DebugVICE = 1
TryGoodGaps = 1


.ifdef DebugVICE

	* = BUFFER2 - 2
	.byte 0, $C0

.else

	* = BUFFER2

.endif

	jmp JobRoutine
	jmp Start

; This is the IRQ routine
JobRoutine

	; set the current buffer address
	; BUFPTR = 0 is assumed!
	lda #>BUFFER1
	sta BUFPTR+1

.ifdef TryGoodGaps

.else
	; start with a gap which is most likely too small
	lda #MinGAP
	sta GAPLEN
.endif

	; set the value for an empty sector
	; if <Orig> is set, it has the content $4B/$01/$01/.../$01;
	; else, it is set to all 0.
	
	ldy CMDBUF+6	; get <Orig> parameter
	beq NotOrig	; if 0, we do not need to set $4B/$01/.../$01 pattern

	ldy #$00	; start with first byte
	lda #$4b	; value for the first byte
	sta (BUFPTR),y	; store it
	iny		; advance to next byte

	; set all bytes for the sector
NotOrig	tya
ClrBuf	sta (BUFPTR),y
	iny
	bne ClrBuf

	; now, calculate the checksum for the buffer
	tya		; A = 0
ChkBuf	eor (BUFPTR),y
	iny
	bne ChkBuf
	sta CHKSUM	; store the checksum.

	jsr BINGCR	; convert the buffer into GCR, more bytes in $01BB-$01FF

	; copy $01BA-$01FF to $07BA-$07FF
	ldy #$ba
CopyGCR	lda STACK,y
	sta BUFFER4,y
	iny
	bne CopyGCR

NxtTrk	jsr status	; perform handshake for next sector if needed

	; check for write protect
	lda DC_SETTINGS
	and #$10
	beq WrtPrtc

	jsr BegWrt	; set write mode, start overwriting
	jsr FrmtTrk	; Format the track

	inc TRACK2	; Increment track number

	lda TRACK2
	cmp CMDBUF+5
	bcs RetOk	; last track written, jump

	; increment the track
	inc DRVTRK	; increment track number

	; advance to next track
	ldy #$02	; advance for 2 half-tracks
AdvTrk	jsr STPIN	; advance one half-track to the inner of the disc

	; wait for R/W head to react
	ldx #$80
Delay	jsr SLOWS
	dex
	bne Delay

	dey
	bne AdvTrk
	beq NxtTrk	; unconditional: Process next track
	; ---------------------------------------------------

RetOk	lda #$01
	.byte $2c

WrtPrtc	lda #$08
	jmp ERRR


; Format one track

FrmtTrk	lda TRACK2	; get track no

.ifdef TryGoodGaps

	ldx #3
ZoneTrk	cmp SpdTrk,x
	beq NewZone
	dex
	bpl ZoneTrk
	bmi OldZone

NewZone
	lda SpdGAP,x
	sta GAPLEN
	lda DC_SETTINGS
	and #$9f
	ora SpdMask,x
	sta DC_SETTINGS

	lda $fed1,x
	sta SECTR

OldZone

.else

	; calculate the speed zone and number of sectors for this track

	cmp ZONEBOUNDARIES	; is this track <= 35, that is, a standard one?
	bcc StdTrk	; yes, jump

	; set speed zone and no. of tracks for tracks > 35
	lda #35		; pretend we were on track 35

StdTrk	jsr MAXSEC	; get speed zone in X, sectors per track in A

	sta SECTR

	lda DC_SETTINGS
	and #$9f
	ora SpdMask,x
	sta DC_SETTINGS

.endif

	; prepare the header infos for the track
	ldy #$00	; start with sector 0
	sty SECTOR2

PrepSec	lda HBID
	sta BUFFER0,y
	lda TRACK2
	sta BUFFER0+3,y
	lda HDRID2
	sta BUFFER0+4,y
	lda HDRID1
	sta BUFFER0+5,y

	lda #$0f	; set the intra header GAP value
	sta BUFFER0+6,y
	sta BUFFER0+7,y

	lda SECTOR2
	sta BUFFER0+2,y

	; calculate checksum and store it
	eor TRACK2
	eor HDRID2
	eor HDRID1
	sta BUFFER0+1,y

	; advance write pointer by 8
	tya
	clc
	adc #$8
	tay

	; advance sector number and continue if this was not the last one
	inc SECTOR2
	lda SECTOR2
	cmp SECTR
	bcc PrepSec

	; convert $0300-... into GCR ($01BB-$01FF)
	lda #>BUFFER0
	sta BUFPTR+1
	jsr FBTOG

	; copy GCR data to $0300-$0344
	ldy #$ba
	jsr MOVUP	; move $0300-$03BA to $0345-$03FF
	jsr MOVOVR	; move $01BB-$01FF to $0300-$0344

Restart

.ifdef DebugFormat

; this implementation is only for counting
; the no. of writes and remembering the GAPs
	ldx TRACK2
	dex
	inc StTry,x
	lda GAPLEN
	sta StGap,x

; this is the "real" Restart:
.endif

	lda #$00
	sta HDRPNT

	; store the next sector onto disc
NxtSec	ldy GAPLEN
	jsr SyncWrt	; write GAP & sync

	; write header info onto disc
	ldx #$0A	; write 10 byte
	ldy HDRPNT	; where to start with data

SecByte	bvc SecByte	; wait for end of previous byte
	clv
	lda BUFFER0,y	; write next byte
	sta DC_DATA	; to DC
	iny
	dex
	bne SecByte

	sty HDRPNT	; remember where to get the next hdr byte from

	; write gap between header and data block
	ldy #$09	; 9 byte GAP
	jsr SyncWrt	; write GAP and sync

	; write the data block
	ldy #$bb
DtaByt	bvc DtaByt
	clv
	lda BUFFER4,y
	sta DC_DATA
	iny
	bne DtaByt

DtaByt2	bvc DtaByt2
	clv
	lda BUFFER1,y
	sta DC_DATA
	iny
	bne DtaByt2

	; check if there is another sector to be written
	dec SECTOR2
	bne NxtSec	; another sector, process that one

	; put DC into read mode again and quit
	jsr KILL
	; ----------------------------------------------------

	; try to find out how many byte are left until the next SYNC mark

;	ldy #0	; unnecessary

	ldx GAPLEN

	dey		; Y = -1; this is the marker that the GAP is too big

	; test for sync
RdWait	lda DC_SETTINGS
	bpl SyncFnd
	bvc RdWait	; wait for the next byte
	clv
	LDA DC_DATA	; clear the value from the buffer
	dex
	bne RdWait
	iny
	ldx SECTR
	bne RdWait
	; ---------------------------------


	; we have found a sync. First of all, clear the oldest entry from the
	; input port so that we can get another one
SyncFnd	clv		; allow for accounting the next byte
	lda DC_DATA	; clear the value from the buffer

	sty HDRPNT	; remember the additional GAP we want to add

	ldx #$0A	; read 10 byte
	ldy #0		; where to start with data reading


CmpByte	bvc CmpByte	; wait for end of byte
	clv
	lda DC_DATA	; read data from DC
	cmp BUFFER0,y	; compare with the expected data
	bne Smaller	; we found a wrong sync, we have a problem
	iny
	dex
	bne CmpByte

	; check if there are more byte left than there are sectors
	lda HDRPNT
;	beq Ret
	bpl SyncAdd

	; now, check how much byte are missing for a complete gap.
	; if it is not too much, do not do anything
	cpx #Security
	bcc Ret

	; the GAP was too big. Now, half it (and make sure it is not zero)
Smaller	lda GAPLEN
	lsr
	bne StoreGap
	lda #MinGAP
	bne StoreGap

SyncAdd
	; if the additional gap is smaller one or less, ignore it
	cmp #2
	bcc Ret

	; add the additional gap the the gap already used
	clc
	adc GAPLEN
StoreGap	sta GAPLEN

	; restart the formatting
GapFin	lda SECTR	; reset the sector counter
	sta SECTOR2
	jsr BegWrt	; set write mode, overwrite first byte
	jmp Restart	; beq Restart	; continue with writing of the next sector
	; ----------------------


; write Y times $55, then write 5 times $FF (sync)

SyncWrt	lda #$55

	; handle first byte specially so we save the 6 byte
GapWrt	bvc GapWrt
	sta DC_DATA
	clv
	dey
	bne GapWrt
	ldy #$05
	lda #$ff

; write Y times the contents of A onto disc

BlkWrt	bvc BlkWrt	; wait for end of previous byte
	sta DC_DATA	; write the data byte
	clv
	dey		; another one? than write that
	bne BlkWrt

Ret	rts

BegWrt	; set R/W head into write mode

	lda #$ce
	sta DC_PCR
	lda #$ff
	sta DC_DATADDR

	; Overwrite start of track with 256 x $55 byte
	ldy #$00
	lda #$55
	jmp BlkWrt

	; speedzone masks for setting the correct data rate
SpdMask	.byte $0,$20,$40,$60

.ifdef TryGoodGaps

	; inter sector gap for every speedzone
;SpdGAP	.byte $a,$c,$12,$8
SpdGAP	.byte 7,9,15,5

	; the tracks at which each zone starts
SpdTrk	.byte 31, 25, 18, 1

.endif


; here is the program entry

; the command-line has the following format:
;        M-E<StartLow><StartHigh><Tracks+1><Orig><Bump><ShowProgress>0:<Name>,<ID1><ID2>
;                                                                     1 1 
; Byte:  012    3         4          5        6    7         8       90 1..x x  x    x
;                                                                            +  +    +
;                                                                            1  2    3

; StGap

Start	lda #CMDNUM_NEW	; set the command number for "new" command
	sta CMDNUM	; 

	jsr TAGCMD
	jsr ONEDRV
	lda FILDRV
	jsr SETDRIVENUM

	; set the header id into appropriate zp locations
	ldy FILTBL
	lda CMDBUF,y
	sta HDRID1
	lda CMDBUF+1,y
	sta HDRID2

	; set track number to start with in buffer #2
	lda #StartTrack
	sta TRACK2

	ldx #$02
	stx JOBNUM

	; execute bump if it was given on the command line
	lda CMDBUF+7	; get bump value
	beq NoBump	; if 0, do not execute a bump
	lda #JOB_BUMP
	jsr DOJOB	; execute the job in A

	; execute program in buffer #2
NoBump	lda #JOB_EXEC2
	jsr DOJOB

.ifdef DebugFormat

; ------ only for debugging @@@
	ldx #79
L1	lda StTry,x
	sta $0506,x
	dex
	bpl L1
; ------

.endif

	jsr INITDR	; @@@
	jmp WRITEBAM	; write BAM and quit
	; -------------------------------------

	; wait for handshake if ShowProgress is active
	; this allows the PC to update the progress indicator
status	lda CMDBUF+8	; ShowProgress
	beq back	; if 0, do not handshake, thus quit
	; here, A=1 is assumed

	; set data out
	asl		; A = 2
	sta BC_PB

	; wait for clock in to be 1
	asl		; A = 4
Clk0	bit BC_PB
	beq Clk0

	; release data out
	ldy #$00	
	sty BC_PB

	; wait for clock in to be 0
Clk1	bit BC_PB
	bne Clk1

back	rts

.ifdef DebugFormat

StTry	.byte 0,0,0,0,0	; -5
	.byte 0,0,0,0,0	; -10
	.byte 0,0,0,0,0	; -15
	.byte 0,0,0,0,0	; -20
	.byte 0,0,0,0,0 ; -25
	.byte 0,0,0,0,0	; -30
	.byte 0,0,0,0,0	; -35
	.byte 0,0,0,0,0	; -40

StGap	.byte 0,0,0,0,0	; -5
	.byte 0,0,0,0,0 ; -10
	.byte 0,0,0,0,0 ; -15
	.byte 0,0,0,0,0 ; -20
	.byte 0,0,0,0,0	; -25
	.byte 0,0,0,0,0 ; -30
	.byte 0,0,0,0,0 ; -35
	.byte 0,0,0,0,0 ; -40

.endif
