<!doctype linuxdoc system>

<article>
<!-- $Id: cbm4linux.sgml,v 1.6 2006-05-13 16:27:47 strik Exp $ -->
<title>opencbm 0.4.0 Users Guide
<author>Michael Klein, <htmlurl url="mailto:nip@c64.org" name="nip@c64.org">,
Spiro Trikaliotis, <htmlurl url="mailto:cbm4win@trikaliotis.net"
name="cbm4win@trikaliotis.net">, Wolfgang Moser <htmlurl url="http://d81.de" name="d81.de">
<!-- _DATE_ --><date>2006-04-28

<abstract>
This document describes the opencbm package, a Linux kernel module and Windows
kernel mode driver, and a few user space support programs to control and use
serial devices as used by most Commodore (CBM) 8-bit machines.
</abstract>

<!-- Table of contents -->
<toc>

<!-- Begin the document -->


<sect>Overview<label id="overview">

<p>
The popular Commodore 8-bit home-computers like the C-64 and the VIC-20 are
using a custom serial bus to talk to attached devices (disk drive, printer).
The opencbm kernel module provides an interface to this bus at TALK/LISTEN
level, similar to the one provided by the Commodore kernel routines, but low
level bus control is available as well. The serial devices are connected to
the PC's parallel port via an XM1541 or XA1541 and, optionally, an XP1541 or
XP1571 add-on.

<sect1>Introduction to opencbm<label id="introduction">

<p>
This is version 0.4.0 of opencbm, a kernel device driver for the serial CBM bus
(C64, VIC-20, etc.) for Linux and Windows. opencbm is a join of the two projects
cbm4linux (latest version: 0.3.2) and cbm4win (latest version: 0.1.0a). It
should be noted that both projects were highly related from the beginning, as
cbm4win was just a branch from cbm4linux.

Opencbm should work with any devices that understand the "normal" talk and
listen commands of the CBM IEC bus. It has been tested with several 1541,
1541-II, 1571 and 1581 drives, and a MPS-1200. 1541 clones like the OC-118 have
also been reported to work.

The following cable types are supported: 

<p>
<tscreen><verb>
  XP1571             (cbm4linux version >= 0.2.4, cbm4win version >= 0.1.0)
  XM1541 and XA1541  (cbm4linux version >= 0.2.1, cbm4win version >= 0.1.0)
  XP1541             (cbm4linux version >= 0.2.0, cbm4win version >= 0.1.0)
  Modified XE1541    (only on Linux, obsoleted by the XM1541, 
                      see config.make)
</verb></tscreen>

More information on the different cable types can be obtained on the Star
Commander homepage(http://sta.c64.org/xcables.html)and the file CABLE
(included in this packages).

This package is provided `as is', no warranty of any kind will be
taken for any damage or data loss caused by it or by anyuseof
it.

<p>
*** WARNING *****************************************************

HOTPLUGGING can KILL your hardware. Do not connect anything to
the parallel port while the system is up. Always SHUT DOWN, CON­
NECT, REBOOT. Again, absolutely NO WARRANTY.

*****************************************************************

<sect>Installation<label id="installation">

<p>
Depending on the system you are running opencbm on, there are different ways to
install opencbm. Use the appropriate category for you:

<sect1>Installing opencbm on Linux (cbm4linux)<label id="cbm4linux-install">

<p>
The kernel module (cbm.o) does not require any kernel patches and should
compile right out of the box, at least with kernel 2.2.x and 2.4.x, but 2.0.x
might still work as well.

If you intend to modify the drive routines for `d64copy' and `cbmformat' you
also need a crossassembler. `config.make' comes with rules for A.Fachat's `xa'
(available from funet or http://www.lb.shuttle.de/puffin/cbm4linux) and
Ullrich von Bassewitz' `cl65' (comes with cc65, http://www.cc65.org).
Starting with version cbm4linux 0.2.3, opencbm includes precompiled 6502
binaries, so as long as you don't touch the .a65 files there's no need for a
crossassembler.

This package comes with a .spec file for those who want to build binary .RPMs.
See the RPM documentation for details about the build process. If you upgrade
from a previous (non-RPM) version and want to install a binary RPM, don't
forget to remove the old files hanging aroung (just do "make uninstall",
prferably in the *old* source directory).

<sect2>Compile-time configuration
<p>
The compile-time configuration is located in `LINUX/config.make'. Check the
KERN_FLAGS line if you're running kernel 2.0.x or if you don't want to use the
Linux parport subsystem for some reason. Same goes for SMP machines.


<sect2>Compilation

<p>
Type

<itemize>
<item>make             (no root priviledges required)

to  build  the  kernel module, libraries and utility programs (no
root priviledges required),

<item>make dev         (as root)

to   create   the  character  device "/dev/cbm" with major 10 and
minor 177 (this number is registered,  so  it  shouldn't  collide
with anything else :)). Finally

<item>make install     (as root)

will  install  all  necessary  stuff  to  /usr/local/...  (can be
changed in `config.make')
</itemize>

<sect2>Loading the module

<p>
If  you're  using  the  parport subsystem (which is default), you
should now be able to load the driver module by issuing (as root)

<p>
<itemize>
<item>/sbin/modprobe parport      (unless compiled into the kernel)
<item>/sbin/insmod cbm lp=your_lp   (usually 0, which is default)
</itemize>

<p>
or, when built with -DDIRECT_PORT_ACCESS:

<p>
<itemize>
<item>/sbin/insmod cbm port=your_ioport irq=your_irq
     (default is 0x378 for port, 7 for irq)
</itemize>

Check /var/log/messages for the correct cable type (XA1541/XM1541).


<sect2>Troubleshooting

<p>
Finding the cause of a failure condition can be hard. Anyway, the
following tips might help you:

<itemize>
<item>/var/log/messages might give you some hints.

<item>Using the parport subsystem:

<itemize>
<item>the port is occupied by another device (e.g. lp.o)
     cbm.o does NOT support port sharing (wouldn't work anyway).
     (`cat /proc/parport/port/devices')

<item>parport_pc doesn't use an IRQ.
     /etc/modules.conf should contain something like:
       alias parport_lowlevel parport_pc
       options parport_pc io=0x378 irq=7
     (`cat /proc/interrupts')
</itemize>

<item>Using direct port access:

<itemize>
<item>the port/IRQ is occupied by another driver (e.g. parport.o)
     (`cat /proc/interrupts')
     (`cat /proc/ioports')
</itemize>
</itemize>


<sect2>Device access

<p>
As a first test, I'd suggest something simple like

<tscreen><verb>
    cbmctrl command 8 I0:    (assuming drive 8)
    cbmctrl status 8
</verb></tscreen>

<p>
(no root privileges required)

<p>
Failure can be caused by:
<itemize>
<item>incorrect module parameters
<item>wrong BIOS settings (esp. IRQ)
<item>broken cable
</itemize>

<sect2>Runtime configuration

<p>
You really want to add this to /etc/modules.conf to have the driver loaded on
demand: (/etc/conf.modules on older SuSE systems)

    alias char-major-10-177 cbm
    options cbm [options]

With [options] being one or more of:

<itemize>
<item>lp=<it/lp/       (parport only, as used in /sbin/insmod above)
<item>irq=<it/irq/     (direct port only, as used in /sbin/insmod above)
<item>port=<it/port/   (direct port only, as used in /sbin/insmod above)
<item>cable=<it/n/      force cable type:
                -1  for autodetection (default)
                 0  for XM1541 (non-inverting)
                 1  for XA1541 (inverting)
<item>reset=<it/n/     initializing behaviour:
                -1  smart IEC reset (direct port default)
                 0  no IEC reset
                 1  force IEC reset (parport default)
</itemize>

<p>
Congratulation, you have successfully set up your opencbm installation!


<sect1>Installing opencbm on Windows (cbm4win)<label id="cbm4win-install">

<p>
<it/WARNING! If you have already installed a previous version of CBM4WIN on your
machine, you have to uninstall it before installing a new version. For this, go
to the directory where the old version is located, and enter instcbm
--remove./

First of all, Windows must know about the driver. For this, we must install it
with the instcbm tool. This is done as follows:

<itemize>
<item>Make sure you have a supported operating system up and running.

<item>You need administrator privileges on the Windows machine to perform the
following actions.

<item>At first, you have to make sure you have the needed hardware ready. Do the
following:

<itemize>
<item>Get your VIC 15xx drive (out of the basement, or wherever it is!

<item>Moving cables with equipment turned on can damage either your PC,
and/or the drive, so, be carefull!

<item>Thus, switch off your PC and your VIC 15xx drive!

<item>Connect your XA1541 or XM1541 cable to your PC. If you have a parallel
port cable (XP1541), connect that one, too.

<item>Connect your VIC 15xx floppy drive to the cable

<item>Switch on the PC.
</itemize>

<item>Just download the binary package, and unpack it into an arbitrary
directory.

<item>Get a command-line, and change into the directory you unpackaged the
drivers into.

<item>Type "cd exe"

<item>Type "instcbm" and check the outputs. Its last line should look like No
problems found in current configuration. The program might suggest a reboot,
which you should follow. If it does not, don't worry, instcbm tries to avoid
that if possible.

<item>You might want to have a look at the possible options for instcbm. They
are available by typing "instcbm --help"

<item>If we had to reboot in the previous step, do the following:

<itemize> <item>Go to a command-line, and change into the directory you
unpackaged the drivers into again.

<item>Type "cd exe"

<item>Type "instcbm --check". There should not be any further suggestion for a
reboot. If there is, do not proceed, but contact me instead.
</itemize>

<item>If you want to use another port than LPT1, you must tell this to the
driver. I assume you want to use LPTX, with X being the correct value, then
type: "instcbm --lpt=X --update"
</itemize>

<sect>Checking if the installation is complete
<p>
Here, the installation is complete. Anyway, it is wise to check if the
installation works as expected. For this, do the following:

<itemize>
<item>Now, it is time to switch on the floppy drive. Depending on the type of
cable you are using (XA1541 or XM1541) and the parallel port of your PC, this
drive might keep spinning endless now, because it is continuously resetted.

<item>Now, type "cbmctrl reset" and press enter. If it does not already, the red
floppy drive LED should light up, and the drive should start spinning. After
approximately one second, the red LED should switch off again, and the drive
stops spinning.

<item>Now, type "cbmctrl status 8" to get the status (error) code from the
attached floppy drive. If everythings works fine, your drive should answer with
its identification string. For a 1541, this is something like 73,cbm dos v2.6
1541,00,00, while for a 1571, this line looks like 73,cbm dos v3.0 1571,00,00.
There might also be some variant of this line, depending on the firmware version
of your drive.

<item>Type "cbmctrl status 8" to get the status (error) code from the floppy
drive. As the power on message has been read, your drive should answer with a
00, ok,00,00 string.

<item>Type "cbmctrl detect". This command tries to detect the types of drive
which are connected on the cable. You should see the drive which you posess.

<item>Now, we want to check if we can send anything to the floppy drive. Remove
any diskette from the drive and press "cbmctrl open 8 15 I0". (Make sure the "I"
is an upper-case "I". A lower-case "I" will not work!) This command tries to
initialize the disk. Anyway, since we don't have a disk in the drive, an error
occurs. You should hear the floppy spinning, and in case of a 1541, the R/W-head
should start bumping. After some seconds, the red LED starts starts flashing,
indicating that an error occurred.

<item>Now, press again "cbmctrl status 8" to get the status (error) code from
the floppy drive. As an error occurred before, an error string should be
displayed. For my setup, it is the "21,read error,18,00" string. Furthermore,
the red LED should stop flashing.
</itemize>

If you have come so far, you are sure that you send commands to the floppy, and
receive answers from it. This is very good so far. Furthermore, don't panic:
you do not have to enter these commands over and over again, these are only
tests to make sure that anything is correctly installed.

Now, let's proceed. If you have a D64 file or a floppy disc ready, you can try
transferring it over the cable. Do not use all of the followinng commands, but
only the ones you want to perform.

<itemize>
<item>If you want to transfer an existing floppy from the drive to the PC, use
the following command: "d64copy --transfer=serial2 --warp 8 A.D64", while
replacing A.D64 by the name you want to give to the file. If you have a parallel
cable up and ready, just try with that one: "d64copy --transfer=parallel --warp
8 A.D64".

<item>WARNING THE FOLLOWING COMMAND OVERWRITES ANYTHING THAT WAS ON THE FLOPPY
BEFORE, so make sure you do not need that floppy anymore. If you have a D64 or
D71 on your PC, and you want to write it to a new, already formatted disc, enter
"d64copy --transfer=serial2 --warp A.D64 8" if the file is called A.D64. Again,
if you have a parallel cable, you might want to replace "--transfer=parallel".

<item>WARNING THE FOLLOWING COMMAND OVERWRITES ANYTHING THAT WAS ON THE FLOPPY
BEFORE, so make sure you do not need that floppy anymore. If you have a disc
you want to format, you have two options: Either use the command "cbmctrl
command 8 N0:NAME,ID", or use the cbmformat program.
</itemize>

<p>
If you want to completely remove the cbm4win driver from your machine, you can
do so by issuing a "instcbm --remove" command.

You can have a look at the available cbmctrl commands by issuing cbmctrl on
your command line. For the other programs, you get help by issuing the "--help"
option.

<sect1>instcbm
<p>
The following options are available for the "instcbm" tool:

<itemize>
<item> instcbm
	Installs the DLL and the driver on the machine. The driver and the DLL
	are copied into the Windows system directory.

<item>instcbm --nocopy
	Installs the DLL and the driver on the machine. Unlike above, both files
	are not copied, but they are used just "where they are". If you use
	this option, the directory where your files reside must be accessible
	for the system while booting. For example, network drives, USB drives or
	FireWire drives are not allowed.

<item>instcbm --remove
	Uninstall the driver from the machine. The DLL and the driver file
	itself are removed if --nocopy was *not* given at installation time.

<item>instcbm --check
	Check if the installation was set up successfully.

<item>instcbm --lpt=X --update
	(With X a value from 1 to ...) Choose LptX is default port.

<item>instcbm --help
	Print out a short help describing the possible options.
</itemize>

<sect>Utilities<label id="utilities">

<p>opencbm comes with the following utilities:

<sect1>cbmctrl<label id="cbmctrl">

<p><it>cbmctrl</it> is used to send commands to external devices. It can
control all kinds of serial CBM devices like floppy drives and printers. So
far, it has been successfully tested with the disk drives 1541(-II), 1571
and a MPS-1200 printer.

<sect2>Command structure<label id="cbmctrl command structure">
<p>The overall format of all <it>cbmctrl</it> actions is:

<p>Synopsis: <tt>cbmctrl <it>[global_options] </it>ACTION <it>[action_args]</it></tt>
<descrip>
<label id="action-lock">
<tag>global_options</tag>
<p>Some options that are related to <it>cbmctrl</it> in general of which affect
the oervall behaviour of all actions
<tag>action</tag>
<p>One of a bunch of different subcommands that direct <it>cbmctrl</it> what to do
<tag>action_args</tag>
<p>Arguments that are required for the subcommand <it>action</it> to work
</descrip>

<sect3>Global options<label id="cbmctrl global options">
<p><it>cbmctrl</it> understands the following global options

<descrip>
<tag>-h <it>[ACTION]</it>, --help <it>[ACTION]</it></tag>
<p>Outputs the help screen with a short listing of all available actions. If
the optional <it>ACTION</it> name is given also, you retrieve more information
on a special action together with its arguments and parameters
<tag>-V, --version</tag>
<p>Output version information as well as the built date and time
</descrip>

<sect3>Actions overview<label id="cbmctrl actions overview">
<p><it>cbmctrl</it> understands the following subcommand actions
<descrip>
<tag>reset</tag>
<p>Reset all drives on the IEC bus
<tag>detect</tag>
<p>Detect all drives on the IEC bus
<tag>lock</tag>
<p>Lock the parallel port for cbm4win/cbm4linux use
<tag>unlock</tag>
<p>Unlock the parallel port from exclusive usage
<tag>listen</tag>
<p>Perform a listen on the IEC bus
<tag>talk</tag>
<p>Perform a talk on the IEC bus
<tag>unlisten</tag>
<p>Perform an unlisten on the IEC bus
<tag>untalk</tag>
<p>Perform an untalk on the IEC bus
<tag>open</tag>
<p>Perform an open on the IEC bus
<tag>close</tag>
<p>Perform a close on the IEC bus
<tag>popen</tag>
<p>Same as open, but with ASCII to PETSCII conversion
<tag>read</tag>
<p>Get a stream of raw data from an IEC bus device
<tag>write</tag>
<p>Put a stream of raw data to an IEC bus device
<tag>status</tag>
<p>Give the status of a specified drive
<tag>command</tag>
<p>Issue a command to a specified drive
<tag>pcommand</tag>
<p>Same as command, with ASCII to PETSCII conversion
<tag>dir</tag>
<p>Output the directory of a disk in a specified drive
<tag>download</tag>
<p>Download memory contents from a floppy drive
<tag>upload</tag>
<p>Upload memory contents to a floppy drive
<tag>change</tag>
<p>Wait for a disk to be changed in a specified drive
</descrip>

<sect3>Common action arguments<label id="cbmctrl common action arguments">
<p>Many of the <it>cbmctrl</it> subcommands understand the following common
arguments:
<descrip>
<tag>[DEVICE]</tag>
<p>Advice <it>cbmctrl</it> to direct its communication to the IEC bus device
with the number <it>[DEVICE]</it>. IEC bus device numbers can be denoted in
the range from 0 to 30, although no Commodore device is known to use device
numbers 0 to 3. Most commonly used are the numbers 4 (printer) and 8 to 11
(disk drives). Device number 31 is used to denote the UNTALK respectively the
UNLISTEN command code on the IEC bus instead of the TALK respectively LISTEN
command code, therefore device address 31 cannot be used in general.
<tag>[SECADR]</tag>
<p>With several <it>cbmctrl</it> actions the secondary address parameter
<it>[SECADR]</it> denotes a dedicated logical communication channel for the
specifed <it>[DEVICE]</it> . IEC bus channel numbers can be denoted in the
range from 0 to 15. Take note that for floppy disk drive devices some
secondary addresses are interpreted in a special way. Secondary address 0 is
used, when a program is loaded, address 1, when a program is saved. Address
number 15 represents the command channel of the disk drive, so e®ectively,
for bulk data transfers to and from disk drives, only the logical channel
numbers 2 to 14 can be used.
</descrip>

<sect2>Actions<label id="cbmctrl actions">
<p><it>cbmctrl</it> understands the following actions:

<descrip>
<label id="action-reset">
<tag>reset</tag>
This action performs a hardware reset of all devices attached to the IEC bus.
Control is returned after it is made sure that all devices are ready.

<label id="action-detect">
<tag>detect</tag>
This action tries to detect all devices attached to the IEC bus.
For this, this subcommand accesses all possible devices and tries to
read some bytes from its memory. If a devices is detected, its name
is output. Additionally, this routine determines if the device is
connected via a parallel cable (XP1541 companion cable, may be true
for disk drives only).

<label id="action-lock">
<tag>lock</tag>
This command locks the parallel port for the use by opencbm, so that
sequences of e.g. <it/talk//<it/read//<it/untalk or <it/listen//<it/write//<it/unlisten/
are not broken by concurrent processes wanting to access the parallel port.

You should issue <it/cbmctrl lock/ before doing any access to opencbm tools,
and <it/cbmctrl unlock/ after you are done.

<label id="action-unlock">
<tag>unlock</tag>
This command unlocks the parallel port after the use by opencbm.

You should issue <it/cbmctrl lock/ before doing any access to opencbm tools,
and <it/cbmctrl unlock/ after you are done.

<label id="action-listen">
<tag>listen <it/device secadr/</tag>
Tell device <it>device</it> to listen on secondary address
<it/secadr/. Until the next <it/unlisten/ command,
everything output with <it>cbmctrl write</it> will be
received by this device.<p>

This command corresponds to the following 6502 assembly code on a C64:
<code>
lda #device
jsr $ffb1
lda #secadr
ora #$60
jsr $ff93
</code>

<label id="action-talk">
<tag>talk <it/device secadr/</tag>
Tell device <it/device/ to talk on secondary address <it/secadr/. Until
the next <it/untalk/ command, data from this device can be received device by
using the command <it>cbmctrl read</it>.<p>

This command corresponds to the following 6502 assembly code on a C64:
<code>
lda #device
jsr $ffb4
lda #secadr
ora #$60
jsr $ff96
</code>

<label id="action-unlisten">
<tag>unlisten</tag>
Ends communication with listening devices after a <it/listen/ command. This
corresponds to the C64 kernel routine $ffae.

<label id="action-untalk">
<tag>untalk</tag>
Ends communication with talking devices after a <it/talk/ command. This
corresponds to the C64 kernel routine $ffab.

<label id="action-open">
<tag>open <it/device secadr filename/</tag>
Open file <it/filename/ on device <it/device/. After opening, data can be
read/written by sending a <it/talk/ resp. <it/listen/ command with the
secondary address <it/secadr/.

If <it/secadr/ is greater than 1, the file type and access mode must also be
specified by appending <tt/,type,mode/ to <it/filename/. Valid types are
D, P, S, U, R (DEL, PRG, SEQ, USR, REL), valid modes are R for reading and W
for writing.

Note: You cannot do an open without a filename. Although a CBM machine (i.e., a
C64) allows this, this is an internal operation for the Computer only. It does
not have any effect on the IEC bus.

<it/cbmctrl open/ does not change any character encoding, that is, it does not
convert between ASCII (used by the PC) and PETSCII (used by the CBM device). If
this is needed, use <it/cbmctrl popen/ instead.

<label id="popen">
<tag>popen <it/device secadr filename/</tag>
Like <it/cbmctrl open/, but converts the filename from ASCII to PetSCII before
sending it to the floppy.

<label id="action-close">
<tag>close <it/device secadr/</tag>
Close the file associated with secondary address <it/secadr/ on device
<it/device/.

<label id="action-read">
<tag>read <it/[file]/</tag>
This command reads raw data from the IEC bus and outputs it into the given
file, or to stdout if no file is given (or if it is a simple dash, "-").

<label id="action-write">
<tag>write <it/[file]/</tag>
This command writes raw data to the IEC bus; the data is taken from the given
file, or from stdin if no filename is given (or if it is a simple dash, "-").


<label id="action-status">
<tag>status <it/device/</tag>
Copies input from device <it/device/, secondary address 15 (command/status
channel), to the standard output stream. Note that all upper case characters
are changed to lower case. Carriage return (0x0d) is also changed to the
current operating system's line ending convention (0x0a on Unix oriented
systems, 0x0d 0x0a on Windows oriented systems or whatever else is appropriate
for your operating system).

Assuming the device number is 8, this command is similar to (in this case, no
character conversions would be made)
<code>
cbmctrl lock
cbmctrl talk 8 15
cbmctrl read
cbmctrl untalk
cbmctrl unlock
</code>

<label id="action-command">
<tag>command <it/device cmdstr/</tag>
Sends <it/cmdstr/ to device <it/device/, secondary address 15 (command/status
channel). Since there is no PetSCII->ASCII conversion, commands must be sent
in <em/upper case/ (kind of poor man's PetSCII conversion). This is because
charset conversion would break the <tt/M-W/ and <tt/M-E/ commands.

Note: If you need PetSCII->ASCII conversion, use <it/pcommand/ instead.

Assuming the device number is 8, this command is identical to (Note: This does
not work on Windows, because <it/echo/ there does not know the <it/-n/ option.)
<code>
cbmctrl lock
cbmctrl listen 8 15
echo -n cmdstr|cbmctrl write -
cbmctrl unlisten
cbmctrl unlock
</code>

<label id="action-pcommand">
<tag>pcommand <it/device cmdstr/</tag>
Like <it/command/, but converts the data from ASCII to PetSCII before sending
it.

<label id="action-dir">
<tag>dir <it/device/</tag>
Read directory from disk in device <it/device/, print on standard out.

<label id="action-download">
<tag>download <it/device address count [file]/</tag>
Read <it/count/ bytes from drive memory, starting at <it/address/ via one
or more <tt/M-R/ commands. Memory contents are written to standard output
if <it/file/ is ommited or equivalent to <tt/"-"/.

<label id="action-upload">
<tag>upload <it/device address [file]/</tag>
Send <it/file/ to drive memory, starting at <it/address/ via one
or more <tt/M-W/ commands. If <it/address/ is -1, the first two bytes from
<it/file/ are considered as start address. Reads standard input if <it/file/ is
ommited or equivalent to <tt/"-"/.

<label id="change">
<tag>change <it/device/</tag>
Wait for a disc to be changed in the specified device. It waits for the current
disc to be removed, for a new disc to be inserted and for the drive door to be
closed. It does not return until the disc is ready to be read or written.
</descrip>

<sect2>cbmctrl Examples<label id="cbmctrl examples">

<p>
Send file contents to printer 4:
<code>
cbmctrl lock
cbmctrl listen 4 0
cbmctrl write file
cbmctrl unlisten
cbmctrl unlock
</code>

<p>
Copy file to disk drive 8:
<code>
cbmctrl lock
cbmctrl open 8 2 FILENAME,P,W
cbmctrl listen 8 2
cbmctrl write file
cbmctrl unlisten
cbmctrl close 8 2
cbmctrl unlock
</code>

<p>
Copy file from disk drive 8:
<code>
cbmctrl lock
cbmctrl open 8 2 FILENAME,P,R
cbmctrl talk 8 2
cbmctrl read file
cbmctrl untalk
cbmctrl close 8 2
cbmctrl unlock
</code>

<p>
Dump 1541 ROM:
<code>
cbmctrl download 8 0xc000 0x4000 > 1541.rom
</code>
or
<code>
cbmctrl download 8 0xc000 0x4000 1541.rom
</code>

<p>
Write file buffer2.bin to drive 9, address 0x500:
<code/cbmctrl upload 9 0x500 buffer2.bin/

<sect1>cbmformat<label id="cbmformat">
<p>
<it/cbmformat/ is a fast low-level disk formatter for the 1541 and compatible
devices (1570, 1571, third-party clones). The drive routine was taken from the
Star Commander ((C) Joe Forster/STA) and highly improved.

There is also another, very similar tool, <ref id="cbmforng" name="cbmforng">.

<sect2>cbmformat invocation<label id="invoking-cbmformat">
<p>
Synopsis: <tt/cbmformat [OPTION]... DRIVE NAME,ID/

<it/DRIVE#/ has to be the drive number of the disc drive, <it/NAME/ is a name
with up to 16 characters which will be the name of the disc after formatting,
<it/ID/ is the 2-letter disc ID.

<p>Note: Unlike the <it/N0/ command of the drive, the ID must be given (thus,
no so-called "short format" is possible).

<p>
Here's a complete list of known options:

<descrip>
<tag/-h, --help/
Display help and exit.

<tag/-V, --version/
Display version information and exit.

<tag/-n, --no-bump/
Do not bump drive head at the beginning. Don't use this on eventually
misaligned drives.

<tag/-x, --extended/
Format a 40 track disk, the BAM format is compatible to SpeedDOS.

<tag/-c, --clear/
clear (demagnetize) this disc.
This is highly recommended if the disc is used for the first time,
or if it was previously formatted for another system (i.e., MS-DOS).
Note that this option takes much time.

<tag/-v, --verify/
verify each track after it is written.
As this needs an extra round of the drive for each track, the formatting time
is almost doubled.

cf. <ref id="note-1571-cbmformat" name="cbmformat Notes for 1571 drives">

<tag/-o, --original/
Fill sectors with the original pattern (0x4b, 0x01, 0x01...) instead of zeroes.
The original pattern is probably due to a bug in the drive ROM, apart from
this, zeroing out unused sectors should give (slightly) better results for
compressed disk images.

cf. <ref id="note-1571-cbmformat" name="cbmformat Notes for 1571 drives">

<tag/-s, --status/
Display drive status after formatting. Normally, <it/cbmformat/ exits after
executing the drive code. With this option turned on, <it/cbmformat/ waits
until the drive has finished formatting and prints the drive status after
initializing the BAM on standard out.

<tag/-p, --progress/
Display a hash mark ('#') for each formatted track. Slows formatting down a 
bit.
</descrip>

<sect2>cbmformat Notes for 1571 drives<label id="note-1571-cbmformat">
<p>
We encountered problems with decent revision/mechanics combinations of the
1571 disk drives when using cbmformat. We highly recommend to use
<it/--original/ and <it/--verify/ with 1571 drives. From our experience, with
<it/--original/, the problem does not occur; with <it/--verify/, the drive
tests each track after it was formatted and ensures that the failure condition
did not occur.

We did not encounter these problems with either of 1541 (1541-II, 1541C), 1570
or 1571CR (the drive which is part of the C128DCR) drives, only with original
1571 drives.

In the current state, cbmformat is not able to format double-sided discs on a
1571 drive.

<sect2>cbmformat Examples<label id="cbmformat examples">

<p>
Format standard disk (35 tracks) in drive 8:
<code>
cbmformat 8 GAMES,42
</code>

<p>
Format standard disk (35 tracks) in drive 9, use (buggy) 1541 sector pattern (for example, because this is a 1571 drive), show drive status when done:
<code>
cbmformat -os 9 1571disc,71
</code>

<p>
SpeedDOS disk (40 tracks), show progress indicator, all sectors zeroed out,
no head banging:
<code>
cbmformat -npx 8 "40 TRACKS,OK"
</code>

<sect1>cbmforng<label id="cbmforng">
<p>
<it>cbmforng</it> is a fast and reliable low-level disk formatter for the
1541 and compatible devices (1570, 1571, third-party clones). It was based
on <ref id="cbmformat" name="cbmformat"> and is designed to become the
designated successor to <ref id="cbmformat" name="cbmformat">, therefore its
name: <it>CBM-Formatter, the Next Generation</it>.
<p>
Because this is the first official release of <it>cbmforng</it> and because
it was not used in the field by a wider user group, it still contains
additional measurement routines and informational output after the formatting
process was done. When <it>cbmforng</it> prooved its matureness and got back
some features currently missing (progress bar), it will replace
<it>cbmformat</it>.
<p>
To date <it>cbmforng</it> should considered the more reliable formatter;
whenever you should encounter any difficulties with <it>cbmformat</it>, go
for <it>cbmforng</it> . If you like additional informational messages like
e.g. the RPM value each formatted track was measured, then <it>cbmforng</it>
is the tool you want to use. Your feedback helps us to decide, if this
additional output which was needed for developing may find its way into
future releases.

<sect2>cbmforng invocation<label id="invoking-cbmforng">
<p>
Synopsis: <tt/cbmforng [OPTION]... DRIVE NAME,ID/

<it/DRIVE#/ has to be the drive number of the disc drive, <it/NAME/ is a name
with up to 16 characters which will be the name of the disc after formatting,
<it/ID/ is the 2-letter disc ID.

<p>Note: Unlike the <it/N0/ command of the drive, the ID must be given (thus,
no so-called "short format" is possible).

<p>
Here's a complete list of known options:

<descrip>
<tag/-h, --help/
Display help and exit.

<tag/-V, --version/
Display version information and exit.

<tag/-n, --no-bump/
Do not bump drive head at the beginning. Don't use this on eventually
misaligned drives.

<tag/-r, --retries n/
Set the maximum number of retries on errors. This accounts for all
errors that may happen when formatting all the tracks of the whole disc.

<tag/-x, --extended/
Format a 40 track disk, the BAM format is compatible to SpeedDOS.

<tag/-c, --clear/
clear (demagnetize) this disc.
This is highly recommended if the disc is used for the first time,
or if it was previously formatted for another system (i.e., MS-DOS).
Note that this option takes much time.

<tag/-v, --verify/
verify each track after it is written.
As this needs an extra round of the drive for each track, the formatting time
is almost doubled.

cf. <ref id="note-1571-cbmforng" name="cbmforng Notes for 1571 drives">

<tag/-o, --original/
Fill sectors with the original pattern (0x4b, 0x01, 0x01...) instead of zeroes.
The original pattern is probably due to a bug in the drive ROM, apart from
this, zeroing out unused sectors should give (slightly) better results for
compressed disk images. In comparison to <it>cbmformat</it>, the pattern used
with <it>cbmforng</it> is a little bit more original than the one from its
predecessor. On track one the pattern consists of: 0x00, 0x01, 0x01, ...
instead of the first byte beeing 0x4b. This perfectly reflects the original
1541 ROM format bug.

cf. <ref id="note-1571-cbmforng" name="cbmforng Notes for 1571 drives">

<tag/-s, --status/
In addition to the informational output of internal values from the formatting
process, the drive status is displayed.
<!--
Womo: As long as the additional informational output is given after
      formatting, cbmforng does not exit in either case. Therefore
      the following note does not apply yet.

Display drive status after formatting. Normally, <it/cbmforng/ exits
after executing the drive code. With this option turned on, <it/cbmforng/
waits until the drive has finished formatting and prints the drive status
after initializing the BAM on standard out.
-->
</descrip>

<sect2>cbmforng Notes for 1571 drives<label id="note-1571-cbmforng">
<p>
We encountered rare failure conditions with decent revision/mechanics
combinations of the 1571 disk drives when using cbmforng. We highly
recommend to use <it/--original/ and <it/--verify/ with 1571 drives. From
our experience, with <it/--original/, the problem does not occur. With
<it/--verify/, the drive tests each track after it was formatted and ensures
that the failure condition did not occur; otherwise the same track is formatted
again, as often as the currently set retry value allows.

We did not encounter these problems with either of 1541 (1541-II, 1541C), 1570
or 1571CR (the drive which is part of the C128DCR) drives, only with original
1571 drives.

In the current state, cbmforng is not able to format double-sided discs on a
1571 drive.

<sect2>cbmforng Examples<label id="cbmforng examples">

<p>
Format standard disk (35 tracks) in drive 8:
<code>
cbmforng 8 GAMES,42
</code>

<p>
Format standard disk (35 tracks) in drive 9, use (buggy) 1541 sector pattern
(for example, because this is a 1571 drive), show drive status when done:
<code>
cbmforng -os 9 1571disc,71
</code>

<p>
SpeedDOS disk (40 tracks), verify formatted tracks, all sectors zeroed out,
no head banging:
<code>
cbmforng -nvx 8 "40 TRACKS,OK"
</code>


<sect1>d64copy<label id="d64copy">
<p>
<it/d64copy/ is a fast disk image transfer (both read and write) program for
the 1541 and compatible devices (1570, 1571, third-party clones). A 1581 drive
is <it/not/ supported! Maximum transfer speed is achieved by custom drive- and
transfer-routines based on the Star Commander ((C) Joe Forster/STA) routines.

<sect2>d64copy invocation<label id="invoking-d64copy">
<p>
Synopsis: <tt/d64copy [OPTION]... SOURCE TARGET/

<p>
Either SOURCE or TARGET must be an external drive, valid names are 8, 9, 10 and
11. The other parameter specifies the file name of the .d64 image.

Here's a complete list of known options:

<descrip>
<tag/-h, --help/
Display help and exit

<tag/-V, --version/
Display version information and exit.

<tag/-q, --quiet/
Quiet output, fewer messages (also suppresses warnings, should not be used)

<tag/-v, --verbose/
Verbose output, more messages (can be repeated)

<tag/-n, --no-progress/
Omit progress display

<tag>-s, --start-track=<it/start track/</tag>
Set start track (defaults to 1)

<tag>-e, --end-track=<it/end track/</tag>
Set end track (default is 35 for .d64 images, 70 for .d71 images). <it/d64copy/
is able to access tracks 1-35 in <tt/original/ transfer mode and 1-42 with
<tt/serial1/, <tt/serial2/ and <tt/parallel/. The 1571 supports tracks 1-70
in double sided (.d71) mode.

<tag>-t, --transfer=<it/transfer mode/</tag>
Set transfermode. Valid modes are:
<itemize>
<item><tt/auto/     (default)
<item><tt/original/ (slowest)
<item><tt/serial1/
<item><tt/serial2/
<item><tt/parallel/ (fastest)
</itemize>
<tt/original/ and <tt/serial1/ should work in any case.
<tt/serial2/ won't work with more than one device
connected to the IEC bus, 
<tt/parallel/ requires an additional XP1541/XP1571 cable.

<p>
If <tt/auto/ is used, d64copy itself determines the best transfer mode usable
with the current setup, and uses that one. Thus, you will seldom want to 
manually overdrive the <it>transfer mode</it> option.

<tag>-i, --interleave=<it/interleave/</tag>
Set interleave value. This is ignored when reading in warp mode. Default is 16
for transfer mode <tt/original/, for turbo and warp write as follows:
<tscreen><verb>

          turbo (r/w)    warp (write only)
serial1       3                 5
serial2      12                11
parallel      6                 3

</verb></tscreen>
Lower values might slightly reduce transfer times, but if set a bit to low,
transfer times will dramatically increase.

<tag>-w, --warp</tag>
Enable warp mode. This is default now; this option is only supported for
backward-compatibility with opencbm (cbm4linux/cbm4win) versions before 0.4.0.

<tag>--no-warp</tag>
Disable warp mode. Warp mode is usually a good idea for transferring disk
images unless you have a very slow CPU and/or bad disk material. Warp mode
sends raw GCR data over the bus, which assures data integrity on the PC side
and relieves the drive's CPU. Thus, it is unlikely you will want to use that
option.

<tag>-b, --bam-only</tag>
BAM-only copy. Only blocks marked as allocated are copied. For extended tracks
(36-40), SpeedDOS BAM format is assumed. Use with caution, at least one wide-spread
directory editor tends to forget to allocate some directory blocks.

<tag>-B, --bam-save</tag>
Safe BAM-only copy. This is like the <tt/-b/ option but always copies the
entire directory track (18, 18 and 53 in double-sided mode).

<tag>-d, --drive-type=<tt/type/</tag>
Skip drive type detection. <tt/0/ or <tt/1541/ specifies 1541 mode (1 MHz,
parallel cable at VIA $1800), <tt/1/ or <tt/1571/ forces 1571 mode (2 MHz,
parallel cable at CIA $4000).

<tag>-2, --two-sided</tag>
Double-sided mode for copying .d71 images to/from a 1571 drive. Warp mode is
not supported (yet).

<tag>-r, --retry-count=<tt/count/</tag>
Number of retries.

<tag>-E, --error-mode=<tt/mode/</tag>
Controls whether error is appended to the disk image (15x1->PC only).
Allowed values for <tt/mode/ are (abbreviations allowed):
<itemize>
<item><tt/always/
<item><tt/on_error/  (default)
<item><tt/never/
</itemize>

</descrip>

<sect2>d64copy Examples<label id="d64copy examples">

<p>
Read a D64 disc image from the floppy in drive 8 to the file image.d64,
automatically selecting the fastest transfer method:
<code>
d64copy 8 image.d64
</code>

<p>
Copy the D64 disc image in image.d64 to the floppy in drive 9, automatically
selecting the fastest transfer method:
<code>
d64copy image.d64 9
</code>

<p>
Copy a double-sided disc from a 1571 drive 9 to image.d71, using
<tt/serial1/ transfer method and only reading the blocks which are
marked as used in the BAM:
<code>
d64copy -2 -B --transfer=serial1 9 image.d64
</code>

<sect1>cbmcopy<label id="cbmcopy">
<p>
<it/cbmcopy/ is a fast file transfer program for various disk drives,
in particular the 1541, 1570, 1571 and 1581 devices.
Maximum transfer speed is achieved by custom drive- and transfer-routines based
on the Star Commander ((C) Joe Forster/STA) routines.

<sect2>cbmcopy invocation<label id="invoking-cbmcopy">
<p>
Synopsis: <tt/cbmcopy [OPTION]... DEVICE# FILE.../

<p>
DEVICE# specifies the drive number for file copy.
The remaining arguments specify the files to be sent to/read from the disk
drive. This version supports 
Raw, PC64 (P00) and T64 files. They are recognized when sending files to the
disk drive, files read from external devices are always stored as raw binary
data.

Here's a complete list of known options:

<descrip>
<tag/-h, --help/
Display help and exit

<tag/-V, --version/
Display version information and exit.

<tag/-q, --quiet/
Quiet output, fewer messages (also suppresses warnings, should not be used)

<tag/-v, --verbose/
Verbose output, more messages (can be repeated)

<tag/-n, --no-progress/
Omit progress display

<tag/-r, --read/
Operate in read-mode, i.e. read data from an external device.
Starting <it/cbmcopy/ as <it/cbmread/ has the same effect.

<tag/-w, --write/
Operate in write-mode, i.e. send files to an external device.
Starting <it/cbmcopy/ as <it/cbmwrite/ has the same effect.

<tag>-t, --transfer=<it/transfer mode/</tag>
Set transfermode. Valid modes are:
<itemize>
<item><tt/auto/    (default)
<item><tt/serial1/  (slowest)
<item><tt/serial2/
<item><tt/parallel/ (fastest, not possible with a 1581)
</itemize>
<tt/serial1/ should work in any case.
<tt/serial2/ won't work with more than one device
connected to the IEC bus, 
<tt/parallel/ requires a XP1541/XP1571 cable in addition to the XM/XA1541.
If <tt/auto/ is given, or this option is completely omitted, cbmcopy
will automatically determine the fastest transfer method possible with the
current setup. Thus, you will seldom want to  manually overdrive the
<it>transfer mode</it> option.

<tag>-d, --drive-type=<tt/type/</tag>
Skip drive type detection.
Valid types are <tt/1541/, <tt/1570/, <tt/1571/ and <tt/1581/.

<tag>-o, --output=<tt/name/</tag>
Specifies target name. ASCII/PetSCII conversion is performed when in write-mode.

<tag>-a, --address=<tt/address/</tag>
Overrides the file's first two bytes with <it/address/.

<tag/-R, --raw/
Skip file type detection. File data is sent as is.
This option is only valid in write-mode.

<tag>-f, --file-type=<tt/type/</tag>
Specifies/overrides file type. Supported types are <tt/P/, <tt/S/, <tt/D/,
<tt/U/.
Raw files default to <tt/P/, whereas the T64 format contains meta data
which includes the file type. For PC64 files, <it/cbmwrite/ tries to guess
the file type from the file extension.
This option is only valid in write-mode.

</descrip>

<sect2>cbmcopy Examples<label id="cbmcopy examples">

<p>
Read a file called <it/cbmfile/ from drive 8 and store its binary value into
the file file.bin, automatically selecting the fastest transfer method:
<code>
cbmcopy -r 8 cbmfile -o file.bin
</code>

<p>
Write out the file file.p00 in P64 format to the disc in drive 9, using
<tt/serial1/ transfer method:
<code>
cbmcopy -w 9 file.p00
</code>

<sect1>rpm1541<label id="rpm1541">
<p>
rpm1541 is a demo program. It finds out the rotation speed (in rounds per
minute, rpm) of the drive motor of a 1541, 1570 or 1571 drive.
A 1581 drive is <it/not/ supported.

For cbm4linux, rpm1541 is not installed automatically. You have to compile it
yourself if you want to use it. For cbm4win, it is part of the distribution.

<sect2>rpm1541 usage<label id="rpm1541-usage">
<p>
Synopsis: <tt>rpm1541 <it>[device]</it></tt>
<p>
The optional parameter <it>device</it> is the device number of the drive which
should be tested. If not specified, <tt/rpm1541/ utilizes drive 8.

<sect2>rpm1541 Example<label id="rpm1541-example">
<p>

Find out the rotation speed of drive 11:
<code>
cbmctrl lock
rpm1541 11
cbmctrl unlock
</code>

<sect1>flash<label id="flash">
<p>
flash is a demo program. It flashes the drive LED.
flash works with 1541, 1570 or 1571 drives. A 1581 drive is <it/not/ supported.

For cbm4linux, flash is not installed automatically. You have to compile it
yourself if you want to use it. For cbm4win, it is part of the distribution.

<sect2>flash usage<label id="flash-usage">
<p>
Synopsis: <tt>flash <it>[device]</it></tt>
<p>
The optional parameter <it>device</it> is the device number of the drive which
should flash its LED. If not specified, <tt/flash/ utilizes drive 8.

<sect2>flash Example<label id="flash-example">
<p>

Let the drive LED flash on drive 10:
<code>
cbmctrl lock
flash 10
cbmctrl unlock
</code>

<sect1>morse<label id="morse">
<p>
morse is a demo program. It uses the drive LED to output a text in morse code.
morse works with 1541, 1570 or 1571 drives. A 1581 drive is <it/not/ supported.

For cbm4linux, morse is not installed automatically. You have to compile it
yourself if you want to use it. For cbm4win, it is part of the distribution.

<sect2>morse usage<label id="morse-usage">
<p>
Synopsis: <tt>morse <it>[device]</it></tt>
<p>
The optional parameter <it>device</it> is the device number of the drive which
should flash its LED. If not specified, <tt/morse/ utilizes drive 8.

<sect2>morse Examples<label id="morse-examples">
<p>

Morse the text "SOS", "HELLO" and "YOU" (in this order) on drive 9.
<code>
cbmctrl lock
morse 9
cbmctrl command 9 U3:HELLO
cbmctrl command 9 U3:YOU
cbmctrl unlock
</code>


<sect>opencbm API<label id="opencbm-API">
<p>
All communication between the user space applications and the kernel module
is done with ioctl's. Since ioctl's are quite unportable and hardly provide
any type-safety, there are a number of wrapper-functions along with a couple
of convenience functions implemented in <tt/libopencbm.a/ (Linux) or
<tt/opencbm.dll/ (Windows). The prototypes can be found in the header file
<tt/opencbm.h/.

<sect1>Preprocessor macros<label id="opencbm-preproc">
<p>

<itemize>
<item>#define IEC_DATA 0x01</item>
<item>#define IEC_CLOCK 0x02</item>
<item>#define IEC_ATN 0x04</item>
</itemize>

These defines are used by the <it/cbm_iec_*()/ functions. You will definitely
need this if you intend to implement your own custom transfer routines. See
the <tt/libd64copy//<tt/libcbmcopy/ source for more information.

<sect1>Enumeration types<label id="opencbm-enum-types">
<p>

<itemize>
<item>enum cbm_device_type_e
<itemize>
<item/cbm_dt_unknown/
<item/cbm_dt_1541/
<item/cbm_dt_1570/
<item/cbm_dt_1571/
<item/cbm_dt_1581/
</itemize>
</itemize>

<p>
<itemize>
<item>enum cbm_cable_type_e
<itemize>
<item/cbm_ct_unknown/
<item/cbm_ct_none/
<item/cbm_ct_xp1541/
</itemize>
</itemize>

<sect1>Generic types<label id="opencbm-types">

<p>
<itemize>
<item>CBM_FILE</item>
</itemize>

This type is used to take a handle to the CBM driver. Only use this type, as it
hides the differences between Windows and Linux.

An invalid CBM_FILE has value CBM_FILE_INVALID.

<sect1>Functions<label id="opencbm-functions">
<p>

(All functions except <tt/cbm_driver_open():/ <it/f/ must be a valid file
descriptor)

<sect2>Basic I/O<label id="opencbm-basic-functions">

<p><descrip>
<tag/int cbm_driver_open(CBM_FILE *f, int port);/
Opens the driver. <tt/port/ isn't used by now and should be 0.
After successful completion, 0 is returned along with a valid CBM_FILE
descriptor in <tt/f/.

<tag/void cbm_driver_close(CBM_FILE f);/
Closes the driver.

<tag/void cbm_lock(CBM_FILE f);/
The equivalent to <it/cbmctrl lock/. Make sure the parallel port is
kept locked even if the driver is closed with cbm_driver_close().

<tag/void cbm_unlock(CBM_FILE f);/
The equivalent to <it/cbmctrl unlock/. Unlock the parallel port as soon is the
driver is closed with cbm_driver_close().

<tag/int cbm_raw_read(CBM_FILE f, void *buf, size_t size);/
Retrieve data after <tt/cbm_talk();/. At most <tt/size/ bytes are read.
Return value is the actual number of bytes read. &lt; indicates an error.

<tag/int cbm_raw_write(CBM_FILE f, const void *buf, size_t size);/
Send data after <tt/cbm_listen();/. At most <tt/size/ bytes are written,
Return value is the actual number of bytes written. &lt; indicates an error.

<tag/int cbm_listen(CBM_FILE f, __u_char dev, __u_char secadr);/
Tell device <it/dev/ to listen on secondary channel <it/secadr/.
Return value is 0 on success, &lt; 0 means error.

<tag/int cbm_talk(CBM_FILE f, __u_char dev, __u_char secadr);/
Tell device <it/dev/ to talk on secondary channel <it/secadr/.
Return value is 0 on success, &lt; 0 means error.

<tag/int cbm_open(CBM_FILE f, __u_char dev, __u_char secadr);/
Prepare device <it/dev/ for opening a file. This device listens for the file
name after this call which is normally sent by a call to the
<it/write()/-function followed by an <it/unlisten()/ call.
Return value 0 on success, &lt; 0 means error.

<tag/int cbm_close(CBM_FILE f, __u_char dev, __u_char secadr);/
Close file associated with secondary address <it/secadr/ on device <it/dev/.
Return value 0 on success, &lt; 0 means error.

<tag/int cbm_unlisten(CBM_FILE f);/
Send unlisten on bus.
Return value 0 on success, &lt; 0 means error.

<tag/int cbm_untalk(CBM_FILE f);/
Send untalk on bus.
Return value 0 on success, &lt; 0 means error.

<tag/int cbm_get_eoi(CBM_FILE f);/
Get EOI flag after bus read, return value is 0 with no EOI, otherwise 1.
When EOI is set to 1, the active talker has nothing more to send.

<tag/int cbm_clear_eoi(CBM_FILE f);/
Reset EOI flag.
Return value 0 on success, &lt; 0 means error.

<tag/int cbm_reset(CBM_FILE f);/
Do a hardware reset on all connected devices. Control is returned after
a 5 second delay.
</descrip>

<sect2>Low-level port access<label id="opencbm-lowlevel-functions">

<p><descrip>
<tag/__u_char cbm_pp_read(CBM_FILE f);/
Read byte from XP1541/XP1571 bus. No handshaking or such involved.

<tag/void cbm_pp_write(CBM_FILE f, __u_char c);/
Write byte to XP1541/XP1571 bus. No handshaking or such involved.

<tag/int cbm_iec_poll(CBM_FILE f);/
Read status of all bus lines. Return value is a combination of 
<tt/IEC_ATN/, <tt/IEC_CLOCK/ and <tt/IEC_DATA/.

<tag/int cbm_iec_get(CBM_FILE f, int line);/
Get (logical) status of line <it/line/.

<tag/void cbm_iec_set(CBM_FILE f, int line);/
Activate lines <it/line/ (set to 0V).
<it/line/ can be one of or a combination with OR of any of IEC_DATA, IEC_CLOCK,
IEC_ATN.

<tag/void cbm_iec_release(CBM_FILE f, int line);/
Release lines <it/line/ (set to 5V).
<it/line/ can be one of or a combination with OR of any of IEC_DATA, IEC_CLOCK,
IEC_ATN.


<tag/void cbm_iec_setrelease(CBM_FILE f, int setline, int resetline);/
Set lines <it/setline/ (set to 0V) and release line <it/releaseline/ (set to
5V)
<it/setline/ and <it/resetline/ can each be one of or a combination with OR of
any of IEC_DATA, IEC_CLOCK, IEC_ATN. If a line is part of both <it/setline/ and
<it/resetline/, the outcome is undefined.


<tag/int cbm_iec_wait(CBM_FILE f, int line, int state);/
Experimental, do not use.
</descrip>

<sect2>Helper functions<label id="opencbm-helper-functions">

<p><descrip>
<tag/int cbm_upload(CBM_FILE f, __u_char dev, int adr, void *prog, int size);/
Write <it/prog/ into device <it/dev/'s memory space via a series of <tt/"M-W"/
commands.

<tag/int cbm_device_status(CBM_FILE f, __u_char drv, void *buf, int bufsize);/
Read device status info <it/buf/, at most <it/bufsize/ bytes are read.
Returns <it/atoi(buf)/.

<tag/int cbm_exec_command(CBM_FILE f, __u_char drv, void *cmd, int len);/
Execute command <it/cmd/. Returns number of bytes actually written.
if <it/len/ is 0, <it/cmd/ is considered a 0-terminated string.

<tag/int cbm_identify(CBM_FILE f, __u_char drv, enum cbm_device_type_e *t, const char **type_str);/
Tries to identify the device <it/drv/. The hardware type is returned in <it/t/,
<it/type_str/ contains a descriptive string which also includes the drives'
operating system. Both <it/t/ and <it/type_str/ may be <tt/NULL/ in case the
caller is not interrested in any of both values.<p>
The return value is <tt/0/ if the device responded to the <tt/"M-R"/ command,
even if it could not be identified, &lt; 0 indicates error.

<tag/int cbm_identify_xp1541(CBM_FILE f, __u_char drv, enum cbm_device_type_e *t1, enum cbm_cable_type_e *t2);/
Tries to identify the device <it/drv/. The hardware type is returned in <it/t1/,
<it/t2/ contains whether the drive has an parallel (XP1541) cable attached.
Both <it/t1/ and <it/t2/ may be <tt/NULL/ in case the caller is not interrested
in any of both values.<p>
The return value is <tt/0/ if the device responded to the <tt/"M-R"/ command,
even if it could not be identified, &lt; 0 indicates error.

</descrip>

<sect2>PetSCII functions<label id="opencbm-petscii-functions">

<p><descrip>
<tag/char cbm_petscii2ascii_c(char character);/
Converts one character <it/character/ from PetSCII to ASCII.

<tag/char cbm_ascii2petscii_c(char character);/
Converts one character <it/character/ from ASCII to PetSCII.

<tag/char * cbm_petscii2ascii(char *str);/
Convert a null-terminated string <it/str/ from PetSCII to ASCII.

<tag/char * cbm_ascii2petscii(char *str);/
Convert a null-terminated string <it/str/ from ASCII to PetSCII.

</descrip>

<sect2>Parallel Burst functions<label id="opencbm-parburst-functions">

<p><descrip>
<tag/__u_char cbm_parallel_burst_read(CBM_FILE f);/
Support function for mnib. Do not use.

<tag/void cbm_parallel_burst_write(CBM_FILE f, __u_char c);/
Support function for mnib. Do not use.

<tag/int cbm_parallel_burst_read_track(CBM_FILE f, __u_char *buffer, unsigned int length);/
Support function for mnib. Do not use.

<tag/int cbm_parallel_burst_write_track(CBM_FILE f, __u_char *buffer, unsigned int length);/
Support function for mnib. Do not use.

</descrip>

<sect2>libd64copy <it/TODO/<label id="opencbm-libd64copy-functions">
<p>
Not documented yet. See <it/libd64copy/ and <it/d64copy/ source.<p>
Types and prototypes are defined in <tt/d64copy.h/.

<sect2>libcbmcopy <it/TODO/<label id="opencbm-libcbmcopy-functions">
<p>
Not documented yet. See <it/libcbmcopy/ and <it/cbmcopy/ source.<p>
Types and prototypes are defined in <tt/cbmcopy.h/.


<sect>Misc

<sect1>Credits

<p>
The fast format drive routine used by `cbmformat' and the turbo and warp drive
routines used in `libd64copy' and `libcbmcopy' are heavily based on Joe
Forster/STAs Star Commander routines.

The XP1541 and XP1571 cables (C) by Joe Forster/STA.
The original XE1541 cable (C) by Nicolas Welte and Wolfgang Moser
The XA1541 cable (C) by Michael Klein and Nicolas Welte

<sect1>Contributions

<p>
People who directly or indirectly contributed to opencbm (in no particular
order):

<itemize>
<item>
<it/Michael Klein/ started the original cbm4linux work (which was a very big
part)
<item>
<it>Joe Forster/STA</it> made the Star Commander and supplied the source and
about the X?1541 interfaces; who knows, without this work, opencbm might never
have appeared at all.
<item>
<it/Nicolas Welte/ helped with the XA1541 and XM1541 interfaces and supplied a
free factory-new 1571 mechanic for Michael
<item>
<it/Andreas Boose & the VICE team/ made VICE
<item>
<it/André Fachat/ made the xa 6502 crossassembler
<item>
<it/Ullrich von Bassewitz/ made the ca65 crossassembler
<item>
<it/Wolfgang Moser/ contributed <it/many/ discussions, patches, and hardware
whenever it was needed.
<item>
<it/Spiro Trikaliotis/ with discussions, lots of fixes and doing an overall
great review while porting the driver to "other" operating systems ;-)
</itemize>

<p>
And anyone else who sent patches, suggestions, praises & flames!

<sect1>Feedback

<p>
Feel free to drop me a note if you have ideas, patches etc. or if
you just want to tell me how happy you are with this program ;-)


Have fun,
The opencbm team.

</article>
